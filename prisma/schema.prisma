// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum ApplicationStatus {
  OPEN
  HIRED
  REJECTED
  GHOSTED
}

enum WorkMode {
  ONSITE
  HUBRID
  REMOTE
}

enum InterviewChannel {
  EMAIL
  CALL
  VIDEO
  ONSITE
  CHAT
  OTHER
}

enum EventOutcome {
  PASS
  FAIL
  PENDING
}

enum MessageDirection {
  INBOUND
  OUTBOUND
  UNKNOWN
}

enum StageType {
  APPLIED
  RECRUITER_SCREEN
  TECH_SCREEN
  TAKE_HOME
  CULTURAL
  ONSITE
  HM_CHAT
  OFFER
  NEGOTIATION
  OTHER
}

// User related Models
model User {
  id              String    @id @default(cuid())
  email           String    @unique
  passwordHash    String? // null if OAuth-only later
  emailVerifiedAt DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  sessions           Session[]
  emailVerifications EmailVerificationToken[]
  passwordResets     PasswordResetToken[]
  applications       Application[]
  oauthAccounts      OAuthAccount[]
}

model Session {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
  ip        String?
  userAgent String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model EmailVerificationToken {
  id          String    @id @default(cuid())
  userId      String
  tokenHash   String    @unique
  sentToEmail String
  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  usedAt      DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model PasswordResetToken {
  id          String    @id @default(cuid())
  userId      String
  tokenHash   String    @unique
  sentToEmail String
  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  usedAt      DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

// Application related Models
model Application {
  id     String            @id @default(cuid())
  userId String
  status ApplicationStatus @default(OPEN)

  companyName String
  roleTitle   String
  jobUrl      String?
  location    String?
  workMode    WorkMode?
  source      String? // linkedin, referral, etc (free text)

  appliedAt       DateTime // when you applied
  firstResponseAt DateTime? // set by system when first INBOUND event is logged
  lastActivityAt  DateTime // maintained by app code for ghosting suggestion

  closedAt  DateTime? // set when status becomes HIRED/REJECTED/GHOSTED
  ghostedAt DateTime?

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  stages InterviewStage[]

  @@index([userId, status])
  @@index([userId, appliedAt])
  @@index([userId, lastActivityAt])
}

model InterviewStage {
  id            String @id @default(cuid())
  applicationId String

  stageType  StageType? // analytics key, optional for backwards-compat
  title      String // Recruiter Screen, Tech Interview, etc
  orderIndex Int // sortable in UI
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  application Application      @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  events      InterviewEvent[]

  @@index([applicationId, orderIndex])
}

model InterviewEvent {
  id      String @id @default(cuid())
  stageId String

  occurredAt DateTime // actual event time
  channel    InterviewChannel
  direction  MessageDirection @default(UNKNOWN)

  notes             String
  feedback          String?
  nextTalkingPoints String?

  followUpAt     DateTime?
  followUpDoneAt DateTime?

  outcome EventOutcome? // pass/fail/pending (optional)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  stage InterviewStage @relation(fields: [stageId], references: [id], onDelete: Cascade)

  @@index([stageId, occurredAt])
  @@index([followUpAt])
}

//OAuth
model OAuthAccount {
  id                String   @id @default(cuid())
  userId            String
  provider          String // "google", "github", etc
  providerAccountId String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}
